// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: expenses.query.sql

package expenses

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createExpense = `-- name: CreateExpense :one
INSERT INTO expenses (expense_category_id, amount_cents, description, date, remarks)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateExpenseParams struct {
	ExpenseCategoryID int32
	AmountCents       int32
	Description       string
	Date              pgtype.Date
	Remarks           string
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (int32, error) {
	row := q.db.QueryRow(ctx, createExpense,
		arg.ExpenseCategoryID,
		arg.AmountCents,
		arg.Description,
		arg.Date,
		arg.Remarks,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createExpenseCategory = `-- name: CreateExpenseCategory :one
INSERT INTO expense_categories (name, description)
VALUES (LOWER($1), $2)
RETURNING id
`

type CreateExpenseCategoryParams struct {
	Lower       string
	Description string
}

func (q *Queries) CreateExpenseCategory(ctx context.Context, arg CreateExpenseCategoryParams) (int32, error) {
	row := q.db.QueryRow(ctx, createExpenseCategory, arg.Lower, arg.Description)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteExpense = `-- name: DeleteExpense :exec
DELETE FROM expenses WHERE id = $1
`

func (q *Queries) DeleteExpense(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteExpense, id)
	return err
}

const deleteExpenseCategory = `-- name: DeleteExpenseCategory :exec
DELETE FROM expense_categories WHERE id = $1
`

func (q *Queries) DeleteExpenseCategory(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteExpenseCategory, id)
	return err
}

const getExpenseById = `-- name: GetExpenseById :one
SELECT id, expense_category_id, amount_cents, description, date, remarks FROM expenses WHERE id = $1
`

func (q *Queries) GetExpenseById(ctx context.Context, id int32) (Expense, error) {
	row := q.db.QueryRow(ctx, getExpenseById, id)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.ExpenseCategoryID,
		&i.AmountCents,
		&i.Description,
		&i.Date,
		&i.Remarks,
	)
	return i, err
}

const getExpenseCategories = `-- name: GetExpenseCategories :many
SELECT id, name, description FROM expense_categories ORDER BY name
`

func (q *Queries) GetExpenseCategories(ctx context.Context) ([]ExpenseCategory, error) {
	rows, err := q.db.Query(ctx, getExpenseCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExpenseCategory
	for rows.Next() {
		var i ExpenseCategory
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpenseCategoryById = `-- name: GetExpenseCategoryById :one
SELECT id, name, description FROM expense_categories WHERE id = $1
`

func (q *Queries) GetExpenseCategoryById(ctx context.Context, id int32) (ExpenseCategory, error) {
	row := q.db.QueryRow(ctx, getExpenseCategoryById, id)
	var i ExpenseCategory
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getExpenses = `-- name: GetExpenses :many
SELECT expenses.id, expenses.expense_category_id, expenses.amount_cents, expenses.description, expenses.date, expenses.remarks, expense_categories.name as category_name
FROM expenses
JOIN expense_categories ON expenses.expense_category_id = expense_categories.id
ORDER BY expenses.date DESC
`

type GetExpensesRow struct {
	ID                int32
	ExpenseCategoryID int32
	AmountCents       int32
	Description       string
	Date              pgtype.Date
	Remarks           string
	CategoryName      string
}

func (q *Queries) GetExpenses(ctx context.Context) ([]GetExpensesRow, error) {
	rows, err := q.db.Query(ctx, getExpenses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpensesRow
	for rows.Next() {
		var i GetExpensesRow
		if err := rows.Scan(
			&i.ID,
			&i.ExpenseCategoryID,
			&i.AmountCents,
			&i.Description,
			&i.Date,
			&i.Remarks,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpensesByCategories = `-- name: GetExpensesByCategories :many
SELECT expenses.id, expenses.expense_category_id, expenses.amount_cents, expenses.description, expenses.date, expenses.remarks, expense_categories.name as category_name
FROM expenses
JOIN expense_categories ON expenses.expense_category_id = expense_categories.id
WHERE expense_categories.name = ANY($1::text[])
`

type GetExpensesByCategoriesRow struct {
	ID                int32
	ExpenseCategoryID int32
	AmountCents       int32
	Description       string
	Date              pgtype.Date
	Remarks           string
	CategoryName      string
}

func (q *Queries) GetExpensesByCategories(ctx context.Context, dollar_1 []string) ([]GetExpensesByCategoriesRow, error) {
	rows, err := q.db.Query(ctx, getExpensesByCategories, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpensesByCategoriesRow
	for rows.Next() {
		var i GetExpensesByCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.ExpenseCategoryID,
			&i.AmountCents,
			&i.Description,
			&i.Date,
			&i.Remarks,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExpense = `-- name: UpdateExpense :exec
UPDATE expenses
SET expense_category_id = $1, amount_cents = $2, description = $3, date = $4, remarks = $5
WHERE id = $6
`

type UpdateExpenseParams struct {
	ExpenseCategoryID int32
	AmountCents       int32
	Description       string
	Date              pgtype.Date
	Remarks           string
	ID                int32
}

func (q *Queries) UpdateExpense(ctx context.Context, arg UpdateExpenseParams) error {
	_, err := q.db.Exec(ctx, updateExpense,
		arg.ExpenseCategoryID,
		arg.AmountCents,
		arg.Description,
		arg.Date,
		arg.Remarks,
		arg.ID,
	)
	return err
}

const updateExpenseCategory = `-- name: UpdateExpenseCategory :exec
UPDATE expense_categories
SET name = $1, description = $2
WHERE id = $3
`

type UpdateExpenseCategoryParams struct {
	Name        string
	Description string
	ID          int32
}

func (q *Queries) UpdateExpenseCategory(ctx context.Context, arg UpdateExpenseCategoryParams) error {
	_, err := q.db.Exec(ctx, updateExpenseCategory, arg.Name, arg.Description, arg.ID)
	return err
}
